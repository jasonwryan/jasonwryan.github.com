---
layout: post
title: "Managing modules with Awk"
date: 2013-09-15 09:23
comments: true
categories: [archlinux, hack] 
---
{%img left /images/post_images/awk.jpg The Great Auk %}
This is an addendum to my two previous posts on 
[compiling kernels](http://jasonwryan.com/blog/2013/08/03/kernels/ 'The first post')
and [automating the process](http://jasonwryan.com/blog/2013/08/24/automating-kernels/ 'The folow up').
In the first of those posts I wrote about a wonderful tool to track the modules
necessary for building a custom kernel with `make localmodconfig`, graysky's
[modprobed_db](https://github.com/graysky2/modprobed_db 'Github repo'). A simple
bash script, `modprobed_db` allows you to build up an array of modules and—as
the name suggests—`modprobe` all of them prior to compilation.

I forked it on github and started to play around with the script (mostly because
I am slightly <acronym title="Obsessive Compulsive Disorder">OCD</acronym> about
constructions 
[like this](https://github.com/graysky2/modprobed_db/blob/master/common/modprobed_db#L62 'awk pipeline'):

{% codeblock lang:sh modprobed_db lines 62-63 %}
cat /proc/modules | awk '{print $1}' | sort -k 1,1 | \
	grep -Ev "$(echo ${IGNORE[*]} | sed -e 's/^/^(/' -e 's/ /|/g' -e 's/$/)$/')" \
	>/tmp/.inmem
{% endcodeblock %}

[After hacking a while](https://github.com/jasonwryan/modprobed_db/blob/jwr/common/modprobed_db 'My branch'),
I started to realize that the venerable UNIX programme
[Awk](http://www.gnu.org/software/gawk/manual/ 'gawk manual on GNU site')
 would, in many ways, be a better tool for this job. Essentially, we want to
 manage three lists: the modules in <span class="file">/proc/modules</span>, a
 list of modules to ignore, and the master list of all modules required prior to
 compilation. This seems perfectly suited to Awk.

 So, in the interests of learning Awk, I decided to rewrite the required
 functionality (or, more correctly, the subset that I required) in this
 language. This wasn't a straightforward task for me. I got stuck a couple of
 times and, as I work in a building full of 
 [neckbeards](http://catalyst.net.nz 'Catalyst website'), I thought I could ask
 for a couple of pointers. To my surprise, no-one I asked seemed interested in
 Awk. Typical responses were along the lines of “just use Perl.”

 Aside from not knowing any
 [Perl](http://www.perl.org/ 'Perl homepage'), and being unlikely to learn any
 in the immediate future, I was bemused by the notion that none of these skilled
 developers rated Awk as a language worth knowing. One of the #awk FAQ's
 specifically addresses this: 
 [Why would anyone still use awk instead of perl?](http://awk.freeshell.org/Frequently_Asked_Questions#toc14 '#awk FAQs')
 The quote by Tom Christiansen is worth repeating here:

 {% blockquote %}
 Awk is a venerable, powerful, elegant, and simple tool that everyone should know. Perl is a superset and child of awk, but has much more power that comes at expense of sacrificing some of that simplicity.
 {% endblockquote %}

In a happy coincidence, this 
[question on Unix & Linux SE](http://unix.stackexchange.com/questions/90489/compare-two-files-with-first-column-and-remove-duplicate-row-from-2nd-file-in-sh/90490#90490 'Comparing two files')
showed up just as I was completing my script and it neatly illustrates (to my
unututored eye, anyway) an example of a typical situation where Awk's strengths
make it a better approach than Perl.

In any event, my rewriting of `modprobed_db` in Awk<sup>1</sup> resulted in this:

{% codeblock lang:awk awkmodules %}
#!/usr/bin/awk -f
# script to manage modules for kernel builds

BEGIN { dbfile = ARGV[2] }

function red(s) {
    printf "\033[1;31m" s "\033[0m "
}

# read in the array
FILENAME != ARGV[3] {
  modlist[$1]++; next
}

# check for ignored modules
!modlist[$1]++ {
  print $1 >> dbfile
  close(dbfile)
  }

{
# modprobe modules
if (p == 1) {
  modload="sudo modprobe -a $(<"dbfile")"
  system(modload)
  close(modload)
  }
}

{
# update module count
if ( getline < dbfile ) {
  count++
  }
}

END {
  print red(count) "modules listed."
}

# vim:set ts=2 sts=2 sw=2 et:
{% endcodeblock %}

Just prior to compiling a kernel, I can invoke this script with (the admittedly
rather ungainly line):

{% codeblock lang:sh %}
awkmodules p=1 .config/kmod_db/ignored .config/kmod_db/modules_db /proc/modules
{% endcodeblock %}

It does work, but I don't claim that it is either idiomatic or attractive. The
use of `getline` to update the module count strikes me as especially kludgy but
I haven't been able to think of a more correct way to handle it.

Incidentally, the gawk manual<sup>2</sup>,
[Gawk: Effective AWK Programming](http://www.gnu.org/software/gawk/manual/ 'GNU goodness')
has only just been updated<sup>3</sup> so Awk is, unlike it's homonym, clearly
alive and well.

#### Notes
1. In my [bitbucket repo](https://bitbucket.org/jasonwryan/shiv/src/tip/Scripts/awkmodules).
2. The number of variants of `awk` is as much a delight as it is perplexing…
3. May, 2013

Public Domain image of the Great Auk by John James Audubon, from his book
[The Birds of America](https://en.wikipedia.org/wiki/File:PinguinusImpennus.jpg).
