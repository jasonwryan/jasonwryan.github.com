<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hack | jasonwryan.com]]></title>
  <link href="http://jasonwryan.github.com/blog/categories/hack/atom.xml" rel="self"/>
  <link href="http://jasonwryan.github.com/"/>
  <updated>2013-06-22T17:27:14+12:00</updated>
  <id>http://jasonwryan.github.com/</id>
  <author>
    <name><![CDATA[Jason Ryan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hacking PKGBUILDs]]></title>
    <link href="http://jasonwryan.github.com/blog/2013/05/18/pkgbuilds/"/>
    <updated>2013-05-18T10:10:00+12:00</updated>
    <id>http://jasonwryan.github.com/blog/2013/05/18/pkgbuilds</id>
    <content type="html"><![CDATA[<p>{% img left http://dl.dropbox.com/u/261312/Blog-images/woodcutting.jpg 'Cutting wood' %}
I posted a couple of weeks ago about
<a href="http://jasonwryan.com/blog/2013/03/29/vim/" title="Post on Vim">Building Vim</a> and how,
using <a href="https://wiki.archlinux.org/index.php/Abs" title="Arch Build System on the Wiki">ABS</a>
and <code>makepkg</code> it is possible to customize packages in the repositories to suit your
individual requirements, in that case with a specific feature set.</p>

<p>One of Arch's real strengths is in the flexibility that <code>makepkg</code> and PKGBUILDs provide
the community; the ability to adapt official packages—or unofficial ones in the
<a href="https://aur.archlinux.org/" title="Arch User Repository">AUR</a>—as you see fit. As PKGBUILDs
are just shell scripts, the entry level to start playing around with them is quite
low<sup>1</sup>.</p>

<p>A fairly standard, and simple, example of the type of customization that I might make
is with <a href="http://tools.suckless.org/dmenu/" title="dmenu page">dmenu</a>, the suckless dynamic
menu, where the
<a href="https://www.archlinux.org/packages/community/x86_64/dmenu/" title="Arch package">standard package</a>
in the Arch repositories is not patched for Xft support. There is a patch for this on the
<a href="http://tools.suckless.org/dmenu/patches/xft" title="Xft patch on suckless.org">suckless wiki</a>, so it
is just a case of making the requisite changes in the PKGBUILD from ABS and building it.</p>

<p>As you can see from the <code>diff</code> below, there is not a lot involved in this exercize; essentially,
adding <code>libxft</code> as a dependency, sourcing the patch from the suckless site (and including the
hash for it), and then in the <code>build</code> function ensuring that the patch is applied and the
Makefile updated with the new library:</p>

<p>{% codeblock lang:diff %}
--- PKGBUILD   2013-05-18 09:33:07.156328812 +1200
+++ PKGBUILD   2012-11-14 09:25:15.915335588 +1300
@@ -11,16 +6,22 @@
 pkgdesc="A generic menu for X"
 url="http://tools.suckless.org/dmenu/"
 arch=('i686' 'x86_64')
+groups=('modified')
 license=('MIT')
-depends=('sh' 'libxinerama')
-source=(http://dl.suckless.org/tools/$pkgname-$pkgver.tar.gz)
-md5sums=('9c46169ed703732ec52ed946c27d84b4')
+depends=('sh' 'libxinerama' 'libxft')
+source=(http://dl.suckless.org/tools/$pkgname-$pkgver.tar.gz
+http://tools.suckless.org/dmenu/patches/$pkgname-$pkgver-xft.diff)
+md5sums=('9c46169ed703732ec52ed946c27d84b4'
+         'd448ec9120718b0aedbdb338f4fa69ba')</p>

<p> build(){
   cd $srcdir/$pkgname-$pkgver
+  patch -p1 &lt; ../$pkgname-$pkgver-xft.diff
+  sed -i 's:-I/usr/local/include/freetype2:-I/usr/include/freetype2:' config.mk
+
   make \
{% endcodeblock %}</p>

<p>Running <code>makepkg -i</code> will build and install dmenu with Xft support. This is the most
straightforward approach. I also, primarily by way of experimentation and in an effort
to try an understand how this actually works, have slightly more convoluted examples.
<a href="https://www.archlinux.org/packages/extra/x86_64/msmtp/" title="Arch package">msmtp</a>, the
<acronym title="Simple Mail Transfer Protocol">SMTP</acronym> client has a couple
of makedepends in
<a href="https://www.archlinux.org/packages/extra/x86_64/libgnome-keyring/" title="Arch package">libgnome-keyring</a>
and <a href="https://www.archlinux.org/packages/extra/any/texlive-core/" title="Arch package">texlive-core</a>; the former
I have zero use for and the latter is only installed on my desktop, so I have no wish to install it on
my laptop just to be able to send emails…</p>

<p>In this case, I modified the PKGBUILD to completely remove the <code>libgnome-keyring</code> dependency
and to only build the <code>msmtp</code> documentation in <code>.pdf</code> and <code>.html</code> if <code>texlive-core</code> was
already installed on the machine. Unfortunately, I wasn't able to test for the presence of
<code>texlive-core</code> with the standard utilities like <code>type</code> or <code>which</code>, so—as it is installed
on all my boxes—I went with <code>expac</code> (<code>pacman -Q</code> would also work):</p>

<p>{% codeblock lang:diff %}
--- PKGBUILD    2013-05-18 09:32:07.393095131 +1200
+++ PKGBUILD    2013-05-18 09:31:55.449986364 +1200
@@ -1,7 +1,8 @@
 arch=('i686' 'x86_64')
+groups=('modified')
 license=('GPL3')
 url="http://msmtp.sourceforge.net"
-makedepends=('texlive-core' 'gsasl' 'libgnome-keyring')
+makedepends=('gsasl')
 source=(http://download.sourceforge.net/sourceforge/msmtp/${pkgbase}-${pkgver}.tar.bz2)
 sha1sums=('c0edce1e1951968853f15209c8509699ff9e9ab5')</p>

<p>@@ -12,19 +13,24 @@</p>

<p> build() {
   cd ${pkgbase}-${pkgver}
-  ./configure --prefix=/usr --sysconfdir=/etc --with-ssl=gnutls
+  ./configure --prefix=/usr --sysconfdir=/etc --with-ssl=gnutls --without-gnome-keyring
   make
-  make -C doc html pdf
+  if [[ -n $(expac -Q '%n' texlive-core) ]]; then
+      make -C doc html pdf
+  fi
 }</p>

<p> package_msmtp() {
   pkgdesc="A mini smtp client"
-  depends=('gsasl' 'libgnome-keyring')
+  depends=('gsasl')
   install=msmtp.install</p>

<p>   cd ${pkgbase}-${pkgver}
   make DESTDIR="${pkgdir}" install
+
+  if [[ -n $(expac -Q '%n' texlive-core) ]]; then
   make DESTDIR="${pkgdir}" -C doc install-html install-pdf
+  fi</p>

<p> # Installing example configs and scripts to /usr/share/doc/msmtp
{% endcodeblock %}</p>

<p>It isn't necessarily an attractive solution, but it works for me…
On the subject of unattractive solutions, as of pacman 4.1, released
last month, the packaging standards for
<a href="https://wiki.archlinux.org/index.php/VCS_PKGBUILD_Guidelines" title="Arch Wiki page">VCS PKGBUILDs</a>
have been changed, principally around how sources and versioning is handled. For
the couple of VCS packages I maintain in the <acronym title="Arch User
Repository">AUR</acronym><sup>2</sup>, I have been
experimenting with how to capture the <code>pkgver</code> in a way that conforms to the
standards and provides people with a meaningful version number.</p>

<p>By default, the version number for these projects from their git repos
is not that helpful:</p>

<p>{% codeblock lang:sh %}
git describe --always
4861046
{% endcodeblock %}</p>

<p>After looking through the git logs, and playing around with <code>awk</code> to filter
the results, I came up with this:</p>

<p>{% codeblock lang:sh %}
pkgver() {
  cd "$<em>gitname"
  printf '%s\n' "$(awk '/^ / {print $2}' &lt;(git log --grep=version -1))</em>\
  $(git describe --always)"
}
{% endcodeblock %}</p>

<p>This prints a more, for me anyway, intelligble package version: <code>vimprobable2-git
1.2.1_c5936cc-1</code> that relates back to the last stable release and appends the
current commit. I'm sure that this could be improved upon; suggestions are
welcome.</p>

<p>The other change to note in all of these PKGBUILDs is the inclusion of the
<code>groups</code> variable. By adding all of the modified packages from the official
repositories to the—imaginatively titled—<code>modified</code> group, I can then add a line
to <code>/etc/pacman.conf</code> that prevents those packages from being overwritten on
upgrade<sup>3</sup>:</p>

<p>{% codeblock lang:sh %}
IgnoreGroup = modified
{% endcodeblock %}</p>

<p>Issuing <code>pacman -Syu</code>, or running <code>checkupdates</code> from a <code>cron</code> job, will
notify you that the packages have had a version bump and that they need
to be rebuilt. The PKGBUILDs for all of these packages can be found in
<a href="https://bitbucket.org/jasonwryan/centurion/src/ff3b3c9d805e197f35aa28dbeb6a9a6555ee7b63/Build?at=default" title="Files in bitbucket">my bitbucket repo</a>.</p>

<h4>Notes</h4>

<ol>
<li>As my experiments attest…</li>
<li><a href="https://aur.archlinux.org/packages/vimprobable2-git/">Vimprobable2-git</a>,
<a href="https://aur.archlinux.org/packages/surfraw-git/">Surfraw-git</a> and
<a href="https://aur.archlinux.org/packages/ruby-build-git/">ruby-build-git</a>.</li>
<li>All credit to ataraxia <a href="https://bbs.archlinux.org/viewtopic.php?pid=623841#p623841">for this idea</a>.</li>
</ol>


<p>Creative Commons image on Flickr by
<a href="http://www.flickr.com/photos/wellspwilson/6481217091/" title="Wood
Cutting Wood">Wells P. Wilson</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AUR Helpers]]></title>
    <link href="http://jasonwryan.github.com/blog/2013/04/09/helpers/"/>
    <updated>2013-04-09T19:07:00+12:00</updated>
    <id>http://jasonwryan.github.com/blog/2013/04/09/helpers</id>
    <content type="html"><![CDATA[<p>{% img left http://dl.dropbox.com/u/261312/Blog-images/crutches.jpg 'Crutches on Flickr' %}</p>

<h3>Or, "Why you should uninstall Yaourt and embrace <em>makepkg</em>…"</h3>

<p>The <a href="https://bbs.archlinux.org/viewtopic.php?id=160655" title="Announcement on the Arch boards">release of Pacman 4.1</a>
saw the same flurry of posts on the boards, in IRC and the mailing lists about
people being “unable” to upgrade or, worse, claiming that pacman was “broken”
because their upgrade was failing due to unsatisfied dependencies, that pretty
much every pacman upgrade ocassions. How is it possible that so many people can
run an operating system designed for competent users without having even a
basic understanding of how the package manager—one of the single most critical
components of the distribution—works?</p>

<p>Even a cursory perusal of the resulting threads on the boards will quickly
identify the common denominator in these cases:</p>

<p>{% blockquote %}
resolving dependencies...
looking for inter-conflicts...
error: failed to prepare transaction (could not satisfy dependencies)
:: package-query: requires pacman&lt;4.1
{% endblockquote %}</p>

<p><a href="https://aur.archlinux.org/packages/package-query/" title="AUR page">package-query</a>
is required by <a href="https://aur.archlinux.org/packages/yaourt/" title="yaourt on AUR">yaourt</a>;
so these upgrades have been stymied by a package that is in the (unsupported)
<acronym title="Arch User Repository">AUR</acronym>? There are a
<a href="https://wiki.archlinux.org/index.php/AUR_Helpers" title="Arch Wiki entry">multitude of AUR helpers</a>,
but <code>yaourt</code> is most commonly used by people who are new to Arch<sup>1</sup>
for two reasons.  First, it is one of the most “featureful” and secondly, and
more to the point of my argument, it can be installed by simply adding an
unsupported repo to <code>pacman.conf</code>; thereby effectively bypassing the need for
the hapless user ever having to use or understand <code>makepkg</code>.</p>

<p>Consequently, over time, people who are habitually using <code>yaourt -Syu --aur</code> to
update both the packages in the supported repositories and those they have
installed from the AUR lose the conceptual distinction between the two.
<code>yaourt</code> obscures this from them and—if they are completely reliant upon it, as
these threads attest they are—they have abnegated responsibility for managing
those unsupported packages and in doing so have found themselves incapable of
understanding the bind they are in.</p>

<p>This sort of obscuring of fundamental operating principles in the pursuit of
“convenience” is anathema to Arch and is precisely the reason I moved away from
using <code>yaourt</code> (and indeed from using Ubuntu when I jumped from that sinking
ship). Any convenience is purely illusory, in reality it just fosters
<a href="http://en.wikipedia.org/wiki/Learned_helplessness" title="Wikipedia entry">learned helplessness</a>.</p>

<p>I understand that the <code>yaourt</code> developer(s) was scratching their own itch, and
this post is not about maligning the project; but there are significant
unintended consequences of giving people a tool that abstracts such a
fundamental element of the distribution away from the user, especially for a
distribution where you are expected to have
<a href="https://wiki.archlinux.org/index.php/The_Arch_Way#User-centric" title="The Arch Way">complete control <em>and responsbility</em> over your system</a>.</p>

<p>To be clear, I don't have a complaint with the <em>concept</em> of AUR helpers. I used
<code>yaourt</code> initially before switching to
<a href="http://pbrisbin.com/posts/aurget" title="Patrick Brisbin's AUR helper">aurget</a> and then
alighting on
<a href="https://github.com/falconindy/cower" title="Cower on github">cower</a>, or more particularly,
a partial wrapper for <code>cower</code>:</p>

<p>{% codeblock lang:sh cowerd %}</p>

<h1>!/bin/sh</h1>

<h1>install AUR packages with cower</h1>

<p>cd $HOME/Build &amp;&amp; cower -d "$1"
builddir="$_"
cd "$builddir" &amp;&amp; ${EDITOR:-vi} PKGBUILD</p>

<p>makepkg -si &amp;&amp; cd - &amp;>/dev/null</p>

<p>read -p "Remove Build directory? [Y/n]? " yn
if [ "$yn" = "y" ]; then</p>

<pre><code>printf "\n%s\n" "Removing build directory..." 
rm -rf "$builddir"
</code></pre>

<p>else</p>

<pre><code>printf "%s\n" "Build completed."
</code></pre>

<p>fi
{% endcodeblock %}</p>

<p>This provides me the minimum level of automation I require—essentially only
around downloading and installing a package. It doesn't automatically handle
dependencies, nor manage updating the packages; that remains, rightly in my
view, <em>my</em> responsibility.</p>

<p>If I were to look to a more fully featured wrapper, I would undoubtedly choose
<a href="https://github.com/e36freak/meat" title="meat on Github">meat</a>, however as on my
desktop machine, I only have ~30 AUR packages installed, I don't really need
anything more sophisticated.</p>

<p>So by all means, use an AUR helper. But recognize that it is intended to help
you, not preclude you from being able to accomplish the most simple and
critical task of system maintenance, updating your package manager. Uninstall
<code>yaourt</code> if you are using it and familiarize yourself with <code>makepkg</code>; once you
do understand the relationship between the official repositories and the AUR,
download <code>cower</code> or <code>meat</code>, they are both <em>much</em> better solutions.</p>

<h4>Notes</h4>

<ol>
<li><a href="http://jasonwryan.com/blog/2009/11/21/dzen2-and-conky-cli-in-dwm/" title="Post from 2009">Myself included</a>…</li>
</ol>


<p>Creative Commons image of crutches by
<a href="http://www.flickr.com/photos/wheatfields/118700600/" title="Flickr CC image">net_efekt on Flickr</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Replacing TrueCrypt]]></title>
    <link href="http://jasonwryan.github.com/blog/2013/01/10/truecrypt/"/>
    <updated>2013-01-10T16:02:00+13:00</updated>
    <id>http://jasonwryan.github.com/blog/2013/01/10/truecrypt</id>
    <content type="html"><![CDATA[<p>{% img left https://dl.dropbox.com/u/261312/Blog-images/lock.jpg 'Flickr image of lock' %}
I have used <a href="http://truecrypt.org/" title="TrueCrypt homepage">TrueCrypt</a> since just before
I migrated to Linux, so somwehere around six or seven years, dating back to version 3 or 4.
It is an incredibly handy utility, allowing you to create and manage encrypted volumes on
the fly and—for the especially paranoid—to hide the existence of those volumes from
inquisitive others.</p>

<p>In the intervening years, with all aspects of my personal life
increasingly mediated digitally, in order to properly safeguard my privacy,
and that of my family, I have taken to using LUKS to
<a href="http://jasonwryan.com/blog/2012/02/11/lvm/" title="Post on LVM on LUKS">fully encrypt all of my machines</a>.
And I have used TrueCrypt, both personally and for work, to encrypt some of my USB drives and as
a container in <a href="http://dropbox.com/" title="Dropbox homepage">Dropbox</a>
, for as long as
<a href="http://jasonwryan.com/blog/2010/01/11/using-dropbox-to-share-dotfiles/" title="Post on sharing dotfiles with Dropbox">I have used that service</a>.</p>

<p>Early last year, however, I became aware of concerns that TrueCrypt was not truly open source; that almost
all of the larger distros, including Arch, and the Open Source Initiative did not regard TrueCrypt as
free (as in Freedom) software:</p>

<p>{% blockquote Wikipedia entry on TrueCrypt https://en.wikipedia.org/wiki/Truecrypt %}
The TrueCrypt License has not been officially approved by the Open Source Initiative and is not considered "free" by several major Linux distributions (Arch Linux, Debian, Ubuntu, Fedora, openSUSE, Gentoo), mainly because of distribution and copyright-liability reasons.
{% endblockquote %}</p>

<p>When I initially accessed the page, in February 2012, there was also a paragraph—now removed—that
highlighted further, more alarmist, concerns about the shadowy identity of the people behind
TrueCrypt:</p>

<p>{% blockquote Wikipedia entry retrieved in February 2012 https://en.wikipedia.org/w/index.php?title=TrueCrypt&amp;diff=478623780&amp;oldid=478608477 %}
The anonymity of the developers and the abnormalities mentioned above have led users to raise suspicions about the provenance of the product and speculate about the possible existence of vulnerabilities or backdoors that might exist in the source code or executables. http://www.privacylover.com/encryption/analysis-is-there-a-backdoor-in-truecrypt-is-truecrypt-a-cia-honeypot/ However its open source and it can be check for funerabilities that way. [sic]
{% endblockquote %}</p>

<p>While I don't subscribe to the theory that the CIA have planted a backdoor in the software (if they
had, <a href="https://en.wikipedia.org/wiki/Truecrypt#Operation_Satyagraha" title="FBI operation foiled by TC">it clearly doesn't work</a>),
I was relieved to see at the end of last year that someone had written a simple utility that allows
you to manage TrueCrypt containers from the command line; <a href="https://github.com/bwalex/tc-play" title="tcplay on Guthub">tcplay</a>
is decribed as:</p>

<p>{% blockquote %}
a free (BSD-licensed), pretty much fully featured (including multiple keyfiles, cipher cascades, etc) and stable TrueCrypt implementation.
{% endblockquote %}</p>

<p>With a <a href="https://github.com/bwalex/tc-play/blob/master/LICENSE" title="tcplay license">simple, two paragraph license</a>
and a brief but comprehensive <code>man</code> page, I was sold. I uninstalled TrueCrypt late last year and haven't missed it since. Quite
the contrary. The only “issue” that I have had with tcplay is remembering the commands to map and mount a drive.
Initially, I jotted down some notes, but opening them up several times a week to refer to them quickly seemed
pointless so I eventually wised up and wrote a wrapper script to do the job for me…</p>

<p>The script is quite simple, it finds the first available loop device, maps the encrypted volume to it and
mounts it read-writeable for your user.</p>

<p>{% codeblock lang:sh %}</p>

<h1>!/bin/bash</h1>

<h1>manage truecrypt containers using tcplay</h1>

<p>user=jason
cryptdev=Safebox
cryptpath=/home/jason/Dropbox/"$cryptdev"
loopdev=$(losetup -f)
mountpt=/media/"$cryptdev"</p>

<h1>must be run as root</h1>

<p>if [[ $EUID != 0 ]]; then
  printf "%s\n" "You must be root to run this."
  exit 1
fi</p>

<h1>unecrypt and mount container</h1>

<p>if [[ "$1" == "open" ]]; then
  losetup "$loopdev" "$cryptpath"
  tcplay --map="$cryptdev" --device="$loopdev"</p>

<p>  # read passphrase
  read -r -s passphrase &lt;&lt;EOF
  "$passphrase"
EOF</p>

<p>  # mount container
  [[ -d "$mountpt" ]] || mkdir "$mountpt"</p>

<p>  # mount options
  userid=$(awk -F"[=(]" '{print $2,$4}' &lt;(id "$user"))
  mount -o nosuid,uid="${userid% <em>}",gid="${userid#</em> }" /dev/mapper/"$cryptdev" "$mountpt"</p>

<h1>close and clean up…</h1>

<p>elif [[ "$1" == "close" ]]; then
  device=$(awk -v dev=$cryptdev -F":" '/dev/ {print $1}' &lt;(losetup -a))
  umount "$mountpt"
  dmsetup remove "$cryptdev" || printf "%s\n" "demapping failed"
  losetup -d "$device" || printf "%s\n" "deleting $loopdev failed"
else
  printf "%s\n" "Options are open or close."
fi
{% endcodeblock %}</p>

<p>Once you are done, the script will unmount your volume and clean up. Undoubtedly, the
script could be improved; patches are welcome.</p>

<p>There is a
<a href="https://aur.archlinux.org/packages/tcplay-git/" title="Arch User Repository">PKGBUILD in the AUR</a>.
Uninstall TrueCrypt and give tcplay a go, it is a simple, powerful application; and it <em>is</em>
free software…</p>

<h4>Notes</h4>

<p>Creative Commons image on Flickr by <a href="http://www.flickr.com/photos/xserve/368758286/" title="Licensed CC by xserv">xserv</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improved Notes Utility]]></title>
    <link href="http://jasonwryan.github.com/blog/2012/09/01/notes-updated/"/>
    <updated>2012-09-01T10:09:00+12:00</updated>
    <id>http://jasonwryan.github.com/blog/2012/09/01/notes-updated</id>
    <content type="html"><![CDATA[<p>{% img left http://dl.dropbox.com/u/261312/Blog-images/notes.jpg 'Notepad image on Flickr' %}
Nearly two years ago, I posted about my adaption of a simple
<a href="http://jasonwryan.com/blog/2010/09/28/command-line-notes/" title="My post in 2010">command line note utility</a>.
I have used this setup on all of my machines on a daily basis since and it has worked
marvellously. Symlinking to a folder in
<a href="https://www.dropbox.com/home" title="Dropbox home">Dropbox</a> means that the notes are accessible
from all my machines, including my phone. There has only really been one aspect of this setup
that has been sub-optimal.</p>

<p>As an inveterate note-taker (this is one of the “benefits” of ageing; the speed with
which you forget information outpaces the acquisition of newer material) I have—in
those intervening years—built up quite a store of notes. Consequently, in order to
maintain a semblance of order, I have arranged them in a series of directories. There
is a minor flaw with this approach: retreiving a note depended on two factors, a) excellent
recall<sup>1</sup> and, b) accurately typing out the full path. Neither of these are things that I
am inherently good at or inclined to master.</p>

<p>This had been irritating me for some time before I came across this
<a href="http://unix.stackexchange.com/questions/11906/how-to-change-the-target-directory-for-tab-completion" title="Tab completion for notes function">question on Unix &amp; Linux StackExchange</a>.
This provided me with a partial solution to the issue but, as I note in my answer, I was not
able to solve it for nested directories, which was my particular use case. Once I had
muddled my way through the solution on U&amp;L I pushed it to the back of my mind and
tried to ignore it.</p>

<p>Recently, though, the accumulation of notes and the frustration of trying to access them
without <kbd>Tab</kbd> completion drove me to do something about it.</p>

<p>The documentation on
<a href="http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html" title="Bash Manual">programmable completion</a>
is typically terse and searching the web returns very little in the way of instructions
as to how to accomplish this.<sup>2</sup> Undeterred, I decided to hack up a completion
function that worked for nested directories.</p>

<p>What I arrived at was this:
{% codeblock lang:sh %}
shopt -s globstar
shopt -s progcomp</p>

<p>n() { $EDITOR $HOME/.notes/"$*".txt ;}</p>

<p> # completion for notes
_notes() {
local cur
    cur=${COMP_WORDS[COMP_CWORD]}</p>

<pre><code>files=($HOME/.notes/**)
file="${files[@]##*/}"
COMPREPLY=( $( compgen -f "${file[@]}" -- ${cur} ) )
</code></pre>

<p>}
complete -o default -F _notes n
{% endcodeblock %}</p>

<p>The best that can be said about it is that it <em>nearly</em> works…<sup>3</sup></p>

<p>Realising that I was completely out of my depth, I turned to #bash for help, and
I was indeed fortunate that
<a href="https://github.com/geirha" title="geirha's Gitgub">geihra</a> offered some much needed
assistance. geirha's solution is an elegant one:</p>

<p>{% codeblock lang:sh %}
n() {
local arg files=(); for arg; do files+=( ~/".notes/$arg" ); done
${EDITOR:-vi} "${files[@]}"
}</p>

<p>_notes() {
local files=($HOME/.notes/<em>*/"$2"</em>)</p>

<pre><code>[[ -e ${files[0]} ]] &amp;&amp; COMPREPLY=( "${files[@]##~/.notes/}" )
</code></pre>

<p>}
complete -o default -F _notes n
{% endcodeblock %}</p>

<p>In addition to working exactly as I hoped, it had the benefit of introducing me
to a couple more bash concepts that I hadn't encountered;
<a href="http://mywiki.wooledge.org/BashGuide/Arrays" title="Bash Guide on Greg's Wiki">adding elements to an array</a>
with <code>+=()</code> being one. For posterity, the full script is:</p>

<p>{% codeblock lang:sh %}
n() {
local arg files=(); for arg; do files+=( ~/".notes/$arg" ); done
${EDITOR:-vi} "${files[@]}"
}</p>

<p>nls() {
tree -CR --noreport $HOME/.notes | awk '{</p>

<pre><code>if (NF==1) print $1; 
else if (NF==2) print $2; 
else if (NF==3) printf "  %s\n", $3 
}'
</code></pre>

<p>}</p>

<p> # TAB completion for notes
_notes() {
local files=($HOME/.notes/<em>*/"$2"</em>)</p>

<pre><code>[[ -e ${files[0]} ]] &amp;&amp; COMPREPLY=( "${files[@]##~/.notes/}" )
</code></pre>

<p>}
complete -o default -F _notes n
{% endcodeblock %}</p>

<h4>Notes</h4>

<ol>
<li>The alternative to remembering the full path name is to list all of the notes before
each operation with the <code>nls</code> function; this is not ideal either…</li>
<li>Which means that it is either so straightforward that few have bothered to write up their
experiences (most likely), or so arcane that not many have bothered (how it
feels to me). However, there are a couple of pages that I referenced in addition
to the official documentation:

<ul>
<li><a href="http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html">Adam Backstrong's post</a></li>
<li><a href="http://fahdshariff.blogspot.co.nz/2011/04/writing-your-own-bash-completion.html">Fahd Shariff's post</a></li>
<li><a href="http://devmanual.gentoo.org/tasks-reference/completion/index.html">Gentoo Development Guide</a></li>
</ul>
</li>
<li>It fails, as geirha pointed out, because it breaks the filenames on whitespace.</li>
</ol>


<p>Creative Commons image on Flickr by
<a href="http://www.flickr.com/photos/nicholasjon/4101203095/" title="Field Notes etc on Flickr">nicholasjon</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Mercurial Queues]]></title>
    <link href="http://jasonwryan.github.com/blog/2012/07/24/queues/"/>
    <updated>2012-07-24T19:18:00+12:00</updated>
    <id>http://jasonwryan.github.com/blog/2012/07/24/queues</id>
    <content type="html"><![CDATA[<p>{% img left http://dl.dropbox.com/u/261312/Blog-images/queue.jpg 'Queue image on Flickr' %}
Over the last week or so, I have finally gotten around to digging into the whole concept of
using
<a href="http://hgbook.red-bean.com/read/managing-change-with-mercurial-queues.html" title="Chapter on queues in the Mercurial book">Mercurial Queues</a>
to manage patches against an upstream project; in my case
<a href="http://dwm.suckless.org" title="The truly suckless window manager…">dwm</a>.<sup>1</sup>
Essentially, this mercurial extension helps you manage a stack of patches on
top of a directory tree. This gives you quite a lot of fine-grained control
over your patchset and assists immeasurably with automating the application of
patches when the underlying codebase changes.</p>

<p>After having played around with queues for the last couple of days, I am quite
impressed: both the concept and the execution are simple and powerful. The concept
of Mercurial Queues is best described in the Mercurial book: the aptly titled,
<em>Mercurial: The Definitive Guide</em>:<sup>2</sup></p>

<p>{% blockquote Mercurial, The Definitive Guide http://hgbook.red-bean.com/read/managing-change-with-mercurial-queues.html %}
MQ's marriage of distributed revision control with patches makes it much easier to isolate your work. Your patches live on top of normal revision history, and you can make them disappear or reappear at will. If you don't like a patch, you can drop it. If a patch isn't quite as you want it to be, simply fix it—as many times as you need to, until you have refined it into the form you desire.
{% endblockquote %}</p>

<p>I followed Filippo Negroni's excellent
<a href="http://dwm.suckless.org/customisation/patch_queue" title="Step-by-step guide">tutorial on the dwm site</a>
to setup my own
<a href="http://pikacode.com/jasonwryan/dwm-patchset/files/default" title="Patchset on Pikacode">dwm patchset</a>
based on
<a href="http://hg.suckless.org/dwm" title="dwm hg repository">tip</a>, and the process was
surprisingly straightforward; the only caveat being it is a good idea to plan
quite carefully what changes you want in each particular patch. Once I had
completed the setup, it got me thinking about the fact that the final install
is done without <code>pacman</code>, just using <code>make install</code>. And, as a proof-of-concept
more than anything else, I wondered whether this functionality could be used
with <code>makepkg</code>.<sup>3</sup></p>

<p>Turns out, as you might expect with Arch, it was not much of a job to set it
up at all.</p>

<p><strong>Note</strong>: this doesn't mean I think it is a good idea; I was just interested
to see <em>if</em> it could be done and <em>how</em> it would work once it was set up. For something
like dwm, this is definitely a case of introducing a huge amount of complexity for
no apparent benefit (for those people running Gnome, this may quite appeal to you…).</p>

<p>I have a
<a href="http://pikacode.com/jasonwryan/Centurion/file/default/Build/dwm-hg/PKGBUILD" title="If you must…">working PKGBUILD</a>
that you can use if you want to follow along at home. Once you have downloaded
it into <span class="file">dwm-hg/</span>, run <code>makepkg</code> to clone the dwm
repository and build the binary.  Then you need to make sure that the mercurial
queue extension is enabled, so your <span class="file">.hgrc</span> needs to
contain:</p>

<p>{% codeblock lang:sh %}
[extensions]
hgext.mq =
{% endcodeblock %}</p>

<p>Now, you need to setup the queue repository. We do this in <code>$srcdir</code>, which
is <span class="file">dwm-hg/src/dwm</span>:</p>

<p>{% codeblock lang:sh %}
hg qinit -c
{% endcodeblock %}</p>

<p>The next step is to start applying the various patches that you want to comprise
your patchset on dwm. In my case that is base customizations to <span class="file">config.def.h</span>
and three other patches:
<a href="http://pikacode.com/jasonwryan/dwm-patchset/file/default/statuscolours" title="Patch in mercurial queue">statuscolours</a>,
<a href="http://pikacode.com/jasonwryan/dwm-patchset/file/default/cycle" title="ditto">cycle</a>, and
<a href="http://pikacode.com/jasonwryan/dwm-patchset/file/default/push" title="etc…">push</a>.
There are other patches in my repository, one of which patches the appropriate
settings for an Arch build in the
<a href="http://pikacode.com/jasonwryan/dwm-patchset/file/default/setup.makefile" title="Arch settings for Makefiles">relevant makefiles</a>.
This is taken care of by the PKGBUILD in this case.</p>

<p>From here, it is very much as Filippo describes it in his tutorial: make
some changes, add them to the queue and rinse and repeat:</p>

<p>{% codeblock lang:sh %}
hg qnew base.customizations
 # “hack hack hack…”
hg qrefresh
hg qcommit -m 'Added changes to config.def.h to customize'
{% endcodeblock %}</p>

<p>After committing each of your changes as a discrete patch, you can review the queue
with <code>hg qseries</code>:</p>

<p>{% codeblock lang:sh %}
┌─[Centurion ~/Build/dwm-hg/src/dwm]
└─╼ hg qseries
config.customizations
statuscolours
cycle
push
{% endcodeblock %}</p>

<p>And <code>hg qapplied</code> will tell you which of the patches is currently
applied in the working repository; at this stage the list should look
the same as that in <code>hg qseries</code>. The next step is to remove all of the
patches from the queue so that we have a clean repository:</p>

<p>{% codeblock lang:sh %}
┌─[Centurion ~/Build/dwm-hg/src/dwm]
└─╼ hg qpop -a
popping push
popping cycle
popping statuscolours
popping config.customizations
patch queue now empty
{% endcodeblock %}</p>

<p>Should you need to edit a patch, it is simply a matter of popping
to that spot in the stack (you can do so by name or by index
number, beginning at 0):</p>

<p>{% codeblock lang:sh %}
┌─[Centurion ~/Build/dwm-hg/src/dwm]
└─╼ hg qpop config.customizations
popping push
popping cycle
popping statuscolours
now at: config.customizations
 # “hack hack hack…”
hg qrefresh
hg qpush -a
{% endcodeblock %}</p>

<p>Once you are satisfied with the state of the stack, remove all of the
patches to return to the original clean working directory and <code>cd</code> back
to <span class="file">dwm-hg/</span>. You can now use <code>makepkg -fi</code> to
rebuild the package and you should see the pushed patches as part of
the output:</p>

<p>{% codeblock lang:sh %}
==> Starting build()...
==> Pushing queued patchset
applying config.customizations
applying statuscolours
applying cycle
applying push
now at: push
dwm build options:
{% endcodeblock %}</p>

<p>…and when you restart dwm, your customizations will be applied.
When new changes are pushed to
<a href="http://hg.suckless.org/dwm" title="dwm mercurial repo">the dwm repo</a>
you can just <code>makepkg -fi</code>, and, if any of the patches fail due
to changes in the underlying code, pop the stack to the failed
patch, rebase the code, <code>hg qrefresh</code> and continue until done.</p>

<p>As I said at the beginning of this post, this isn't a particularly smart way to
use Mercurial Queues, PKGBUILDs or a combination of the two. You are much
better off just cloning dwm to your local repository, initializing a queue
repository and, once you are done setting up your patchset, issuing <code>make &amp;&amp;
sudo make install</code>.</p>

<p>If you have more than one machine, you can easily setup a repository for
your patchset on
<a href="https://bitbucket.org/" title="bitbucket free mercurial hosting">bitbucket</a>
or <a href="http://pikacode.com/" title="Free Mercurial and Git hosting">Pikacode</a>
and host it there: then just pull the patchset queue
from your other boxes and <code>hg qpush -a</code>. If you require a slightly
different patchset for each box, you can use MQ to manage this
process as well. This is where MQ really excels;
I'll cover this in more detail in my next post.</p>

<h4>Notes</h4>

<ol>
<li>See <a href="http://jasonwryan.com/blog/categories/dwm/" title="dwm category in the archives">related dwm posts</a>.</li>
<li>I can't recommend this {book,wiki} highly enough; it is an excellent
example of thorough, accessible documentation.</li>
<li>In the case of something like dwm, this is really irrelevant, as there
is a single tiny binary and a <code>man</code> page, so keeping track of these files on
your system is not an issue at all.</li>
</ol>


<p>Flickr Creative Commons image by
<a href="http://www.flickr.com/photos/bagelmouse/3936852444/" title="Queue image on Flickr">RachelH</a></p>
]]></content>
  </entry>
  
</feed>
